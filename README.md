# Лабораторна робота №12
## Тема: Stream AP
## Виконав(-ли): Ковальчук Станіслав, Сухоручкін Гліб, Янович Марія і Ястремський Богдан
---
## Контрольні питання:

### 1. В чому полягають відмінності між колекціями та стрімами?

Колекції і стріми - це два різні підходи до обробки даних у Java, які мають свої відмінності та використання в різних ситуаціях.

1. **Колекції (Collections):**
   - Колекції в Java (наприклад, ArrayList, LinkedList, HashSet тощо) - це структури даних, що зберігають групи об'єктів. Вони дозволяють зберігати, додавати, видаляти та змінювати елементи колекції.
   - Основна робота з колекціями включає ітерацію по елементах, знаходження конкретних елементів, додавання та видалення елементів тощо.
   - Використовуються для роботи з даними у вигляді колекцій, де потрібно зберігати, організовувати та маніпулювати об'єктами.

2. **Стріми (Streams):**
   - Стріми - це новий API в Java, що був введений в Java 8. Вони дозволяють виконувати потужні функції обробки даних без змінення вихідних даних.
   - Основна ідея стрімів - це обробка даних через послідовність операцій (мапування, фільтрація, згортання, сортування тощо), які можуть бути застосовані до кожного елемента колекції.
   - Стріми використовують функціональні інтерфейси та лямбда-вирази для опису логіки обробки даних, що робить код більш зрозумілим та компактним.
   - Використовуються для виконання операцій з даними, таких як фільтрація, трансформація, агрегація тощо, без проміжного зберігання результатів в колекціях.

Отже, основні відмінності між колекціями і стрімами полягають у тому, що колекції - це структури даних для зберігання та маніпуляції об'єктами, тоді як стріми - це механізм обробки даних, який дозволяє виконувати функції обробки без зміни вихідних даних і зберігає результати обробки тільки при необхідності. Колекції підходять для зберігання та маніпуляції даними, тоді як стріми - для ефективної обробки даних та роботи з ними за допомогою функціонального програмування.

### 2. Що таке термінальні та нетермінальні операції?

Термінальні та нетермінальні операції - це поняття, що використовується в контексті стрімів в Java (Java Streams), які введені у Java 8 для потужної обробки даних.

1. **Термінальні операції (Terminal Operations):**
   - Термінальні операції - це останній крок у ланцюжку операцій над стрімом, який завершує обробку даних та повертає результат. Після виконання термінальної операції, стрім стає "використаним" і не може бути використаний знову.
   - Приклади термінальних операцій: `collect()`, `forEach()`, `reduce()`, `count()`, `min()`, `max()` та інші.

2. **Нетермінальні операції (Intermediate Operations):**
   - Нетермінальні операції - це операції, які можуть бути викликані перед термінальною операцією у ланцюжку операцій над стрімом. Вони виконують деяку обробку даних, але не повертають результат відразу.
   - Приклади нетермінальних операцій: `filter()`, `map()`, `sorted()`, `distinct()`, `skip()`, `limit()` та інші.

Отже, ключова відмінність між термінальними та нетермінальними операціями в стрімах полягає в тому, що термінальні операції завершують ланцюжок операцій та повертають результат, в той час як нетермінальні операції виконують обробку даних, але не повертають результат, доки не буде викликана термінальна операція.

### 3. Що таке stateless- та stateful- операції? Наведіть кілька прикладів кожної з них.

Stateless (безстандартні) та stateful (застандартні) операції - це поняття, які також використовуються в контексті обробки даних, зокрема в Java Streams або в інших механізмах обробки даних. Вони описують характеристики операцій в залежності від того, чи зберігають вони внутрішні стани (state) під час виконання.

1. **Stateless (безстандартні) операції:**
   - Stateless операції - це операції, які не зберігають внутрішні стани під час виконання. Кожен виклик такої операції обробляє дані незалежно від попередніх викликів.
   - Приклади stateless операцій у Java Streams:
     - `filter(Predicate<T>)`: фільтрує елементи стріму за заданою умовою, не зберігаючи стан.
     - `map(Function<T, R>)`: перетворює кожен елемент стріму на новий елемент, не змінюючи стану.
     - `sorted()`: сортує елементи стріму без зміни стану.
     - `limit(long)`: обмежує кількість елементів у стрімі без зміни стану.

2. **Stateful (застандартні) операції:**
   - Stateful операції - це операції, які можуть зберігати та використовувати внутрішні стани під час виконання. Вони можуть залежати від попередніх операцій та змінювати внутрішні стани.
   - Приклади stateful операцій у Java Streams:
     - `distinct()`: видаляє дубльовані елементи, використовуючи внутрішній стан для відстеження унікальності.
     - `sorted(Comparator<T>)`: сортує елементи стріму залежно від зовнішнього порядку.
     - `reduce(BinaryOperator<T>)`: об'єднує елементи стріму за заданою бінарною операцією, що може залежати від стану.

Отже, stateless операції утворюють безстандартний підхід до обробки даних, де кожен виклик операції обробляє дані незалежно від попередніх викликів. У той час, як stateful операції можуть використовувати та змінювати внутрішні стани, відслідковуючи та залежачи від попередніх операцій.

### 4. Що таке короткозамкнуті (short-circuiting) операції? Наведіть кілька прикладів кожної з них.

Короткозамкнуті (short-circuiting) операції - це операції, які припиняють обробку даних та повертають результат, як тільки стає зрозуміло, що подальша обробка не є необхідною для отримання результату. Це ефективний механізм для оптимізації обробки даних та зменшення зайвих обчислень. У Java, короткозамкнутість часто використовується в Java Streams та умовних виразах. Ось кілька прикладів короткозамкнутих операцій:

1. **Короткозамкнуті операції у Java Streams:**
   - `findFirst()`: Повертає перший елемент зі стріму та завершує обробку.
   - `findAny()`: Повертає будь-який елемент зі стріму та завершує обробку.
   - `anyMatch(Predicate<T>)`: Перевіряє, чи задовольняє хоча б один елемент умові, та завершує обробку, якщо знаходить хоча б одне співпадіння.
   - `allMatch(Predicate<T>)`: Перевіряє, чи всі елементи задовольняють умові, та завершує обробку, якщо знаходить невідповідність.
   - `noneMatch(Predicate<T>)`: Перевіряє, чи немає елементів, що задовольняють умові, та завершує обробку, якщо знаходить співпадіння.

2. **Короткозамкнуті умовні вирази (short-circuiting conditional expressions):**
   - `&&` (логічне І): Якщо перший операнд false, то другий операнд не обчислюється.
   - `||` (логічне АБО): Якщо перший операнд true, то другий операнд не обчислюється.

Наприклад, у виразі `a && b`, якщо `a` є false, то `b` не обчислюється, оскільки вже відомо, що результат буде false без обчислення `b`. Такий механізм дозволяє зменшити обчислювальні витрати у випадках, коли подальша обробка не є необхідною для отримання результату.

### 5. Що означають слова super та extends у декларації методу map класу Stream? (<R> Stream<R> map(Function<? super T,? extends R> mapper))

У декларації методу `map` класу `Stream` у Java, слова `super` та `extends` вказують на типові параметри методу та їхні обмеження. Давайте розглянемо це крок за кроком:

1. **`<R>`:** Це типовий параметр методу `map`, що вказує на тип результату, який поверне метод. У вашому випадку, `R` позначає тип елементів, які будуть у стрімі після застосування функції `mapper`.

2. **`Function<? super T, ? extends R>`:**
   - `Function` - це функціональний інтерфейс в Java, який приймає один аргумент (`? super T`) та повертає результат (`? extends R`).
   - `? super T` - означає, що функція `mapper` приймає аргумент, який є типом `T` або будь-яким батьківським типом `T`. Це дозволяє передавати до функції `mapper` об'єкти, які є типом `T` або будь-яким підкласом `T`.
   - `? extends R` - означає, що функція `mapper` повертає об'єкти, які є типом `R` або будь-яким підкласом `R`. Це дозволяє функції `mapper` повертати об'єкти, які є типом `R` або будь-яким його нащадком.

Отже, у декларації методу `map`:
```java
<R> Stream<R> map(Function<? super T,? extends R> mapper)
```
- `T` - тип елементів у вихідному стрімі.
- `R` - тип результату, який поверне функція `mapper`.
- `? super T` - функція `mapper` приймає об'єкти типу `T` або будь-якого його батьківського типу.
- `? extends R` - функція `mapper` повертає об'єкти типу `R` або будь-якого його підкласу.

### 6. В чому полягає різниця між операціями map() та flatMap() ? 

Операції `map()` та `flatMap()` в Java Streams використовуються для обробки елементів у стрімах, проте вони мають деякі важливі відмінності в тому, як вони працюють зі структурою даних.

1. **Операція `map()`:**
   - `map()` використовується для відображення (перетворення) кожного елементу стріма на інший елемент згідно з заданою функцією.
   - Кожен елемент вхідного стріма перетворюється на один вихідний елемент. Наприклад, якщо вхідний стрім містить числа, то за допомогою `map()` можна перетворити кожне число у його квадрат.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> squares = numbers.stream()
                                .map(num -> num * num)
                                .collect(Collectors.toList());
```

2. **Операція `flatMap()`:**
   - `flatMap()` також використовується для відображення, але він використовується у випадках, коли потрібно розгорнути вкладені колекції або стріми у плоский стрім. Він об'єднує (апланує) результати вкладених стрімів у один плоский стрім.
   - Операція `flatMap()` використовується, коли функція-маппер повертає стрім (наприклад, List або Set), і ми хочемо, щоб кожен елемент вихідного стріма був об'єднаний в один плоский стрім.

```java
List<List<Integer>> nestedNumbers = Arrays.asList(
        Arrays.asList(1, 2),
        Arrays.asList(3, 4),
        Arrays.asList(5, 6)
);

List<Integer> flatList = nestedNumbers.stream()
                                       .flatMap(Collection::stream)
                                       .collect(Collectors.toList());
```

У цьому прикладі `flatMap()` дозволяє розгорнути кожний вкладений список у вихідному стрімі в окремі елементи, що дозволяє отримати плоский стрім з усіма числами.

Отже, основна відмінність між `map()` та `flatMap()` полягає в тому, що `map()` використовується для однорівневих трансформацій елементів стріма, тоді як `flatMap()` використовується для розгортання вкладених стрімів у плоский стрім.

### 7. В чому полягає різниця між операціями peek() та forEach() ? 

Операції `peek()` та `forEach()` у Java Streams використовуються для виконання певних дій над елементами стріму, проте вони мають важливі відмінності у своєму застосуванні та впливі на стрім.

1. **Операція `peek()`:**
   - `peek()` використовується для виконання певної дії (наприклад, виведення на екран, логування, зміна значень тощо) над кожним елементом стріма.
   - `peek()` не змінює сам стрім, тобто він залишається незмінним після виконання `peek()`. Ця операція використовується для відлагодження та спостереження за перетворенням елементів стріма без зміни їх.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> squaredNumbers = numbers.stream()
                                      .map(num -> num * num)
                                      .peek(System.out::println) // Виведення на екран кожного числа
                                      .collect(Collectors.toList());
```

2. **Операція `forEach()`:**
   - `forEach()` використовується для виконання певної дії над кожним елементом стріма, але в вигляді об'єктного методу (лямбда-виразу) або виклику методу.
   - Важливо зазначити, що `forEach()` - це термінальна операція, яка завершує обробку стріму, тому після неї неможливо виконувати інші операції над тим же стрімом.
   
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
       .map(num -> num * num)
       .forEach(System.out::println); // Виведення на екран кожного числа в квадраті
```

Отже, основна відмінність між `peek()` та `forEach()` полягає в тому, що `peek()` використовується для відлагодження та спостереження за елементами без зміни стріму, тоді як `forEach()` використовується для виконання певної дії над кожним елементом стріму, але вже у термінальному контексті, завершуючи обробку стріму.

### 8. В чому полягає різниця між операціями findAny() та findFirst() ? 

Операції `findAny()` та `findFirst()` в Java Streams використовуються для отримання першого елемента зі стріма, який відповідає заданому критерію, але вони мають важливі відмінності в тому, як вони поводяться у різних умовах.

1. **Операція `findAny()`:**
   - `findAny()` повертає будь-який елемент, який задовольняє умові, але не гарантується, що це буде перший елемент в стрімі.
   - Ця операція особливо корисна для паралельних стрімів, де ви можете отримати будь-який елемент, який задовольняє умові без зваження на порядок елементів у стрімі.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Optional<Integer> anyNumber = numbers.stream()
                                      .filter(num -> num > 3)
                                      .findAny();
System.out.println(anyNumber.orElse("No number found"));
```

2. **Операція `findFirst()`:**
   - `findFirst()` повертає перший елемент у стрімі, який задовольняє умові.
   - Ця операція придатна, коли вам важливо отримати перший елемент, який відповідає умові, особливо якщо порядок елементів важливий.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Optional<Integer> firstNumber = numbers.stream()
                                       .filter(num -> num > 3)
                                       .findFirst();
System.out.println(firstNumber.orElse("No number found"));
```

Отже, основна відмінність між `findAny()` та `findFirst()` полягає в тому, що `findAny()` повертає будь-який елемент, який задовольняє умові, тоді як `findFirst()` повертає перший елемент у стрімі, який задовольняє умові та має визначений порядок. У більшості випадків `findFirst()` використовується, коли важливий порядок елементів, а `findAny()` використовується, коли вам потрібен будь-який елемент, який задовольняє умові, без зваження на порядок.

### 9. Як і на що впливають проміжні операції sequential(), parallel() та unordered()?

Операції `sequential()`, `parallel()` та `unordered()` впливають на режим виконання та порядок обробки елементів у Java Streams. Давайте розглянемо кожну операцію окремо:

1. **`sequential()`:**
   - Метод `sequential()` вказує на те, що стрім повинен оброблятися в однопотоковому режимі, тобто виконувати операції послідовно в одному потоці.
   - Це є режимом за замовчуванням для стрімів у Java, коли ви не вказуєте явно режим виконання.
   - Зазвичай використовується, коли обробка даних в стрімі не вимагає паралельного виконання та не виправдовує витрат на створення та управління додатковими потоками.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
long count = numbers.stream()
                     .sequential()
                     .filter(num -> num % 2 == 0)
                     .count();
System.out.println("Count of even numbers: " + count);
```

2. **`parallel()`:**
   - Метод `parallel()` вказує на те, що стрім повинен оброблятися в паралельному режимі, тобто операції можуть виконуватися в кількох потоках одночасно для прискорення обробки даних.
   - Це корисно, коли обробка даних у стрімі може бути розділена на незалежні частини, які можна обробляти паралельно.
   - Важливо враховувати, що деякі операції можуть втратити свою ефективність при паралельному виконанні через потребу у синхронізації.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
long count = numbers.stream()
                     .parallel()
                     .filter(num -> num % 2 == 0)
                     .count();
System.out.println("Count of even numbers in parallel: " + count);
```

3. **`unordered()`:**
   - Метод `unordered()` вказує на те, що порядок елементів у стрімі може бути незначним або не має значення.
   - Це може бути корисно для оптимізації паралельної обробки даних, оскільки в деяких випадках гарантований порядок елементів у стрімі може призводити до затримок через потребу у синхронізації.
   - Проте, не кожна операція збереже порядок елементів при використанні `unordered()`, оскільки це залежить від конкретної операції та властивостей стріму.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
long count = numbers.stream()
                     .parallel()
                     .unordered()
                     .filter(num -> num % 2 == 0)
                     .count();
System.out.println("Count of even numbers in parallel with unordered: " + count);
```

Отже, використання `sequential()`, `parallel()` та `unordered()` дозволяє змінювати режим обробки даних у стрімі, що може бути корисним для оптимізації та підвищення ефективності обробки великої кількості даних. Однак потрібно уважно використовувати ці методи, оскільки неправильне їхнє використання може призвести до помилок або незадовільного результату.

### 10. В яких випадках операції forEach() та forEachOrdered() можуть призвести до різних результатів?

`forEach()` та `forEachOrdered()` є методами для виконання дій над елементами стріму у Java. Однак, їх використання може призвести до різних результатів у випадках, коли порядок елементів у стрімі має значення та коли стрім використовується у паралельному режимі.

1. **`forEach()`:**
   - Метод `forEach()` застосовує вказану дію до кожного елементу стріму в довільному порядку, особливо якщо стрім використовується у паралельному режимі (`parallel()`).
   - Це означає, що порядок виконання операцій над елементами не гарантується і може бути випадковим.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.parallelStream()
       .forEach(System.out::println); // Результат може бути в довільному порядку
```

2. **`forEachOrdered()`:**
   - Метод `forEachOrdered()` також застосовує вказану дію до кожного елементу стріму, але забезпечує гарантований порядок виконання операцій над елементами.
   - Це особливо важливо, коли порядок елементів у стрімі має значення і ви хочете зберегти цей порядок під час обробки.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.parallelStream()
       .forEachOrdered(System.out::println); // Результат буде відображений у звичайному порядку
```

Отже, основна відмінність між `forEach()` та `forEachOrdered()` полягає в тому, що `forEach()` дозволяє операціям виконуватися в довільному порядку, особливо при паралельному виконанні, тоді як `forEachOrdered()` гарантує виконання операцій в потрібному порядку незалежно від режиму стріму.

### 11. Чому деякі методи класу IntStream повертають OptionalInt (наприклад: min(), max(), sum()), а деякі – примітивний int (наприклад: count())?

Методи класу `IntStream` в Java дійсно повертають різні типи результатів залежно від їхньої природи та потреб користувача. Ось чому деякі методи повертають `OptionalInt`, а деякі - примітивний `int`:

1. **OptionalInt:**
   - Методи, які можуть повертати `OptionalInt`, зазвичай є агрегатними функціями або операторами, які можуть бути не визначені для певних вхідних даних.
   - Наприклад, методи `min()`, `max()` та `sum()` обчислюють мінімальне, максимальне значення або суму елементів у стрімі. Якщо стрім порожній, то результати цих методів будуть не визначені.
   - Використання `OptionalInt` дозволяє повертати результати агрегації, якщо вони доступні, або пустий результат, якщо агрегація не може бути здійснена через відсутність елементів у стрімі.

```java
IntStream numbers = IntStream.of(1, 2, 3, 4, 5);
OptionalInt min = numbers.min(); // Може повернути OptionalInt з мінімальним значенням

IntStream emptyStream = IntStream.empty();
OptionalInt minEmpty = emptyStream.min(); // Результат буде пустим OptionalInt
```

2. **Примітивний int:**
   - Деякі методи, наприклад `count()`, які повертають примітивні значення, завжди мають значення, навіть якщо стрім порожній.
   - Наприклад, метод `count()` повертає кількість елементів у стрімі. Якщо стрім порожній, то результат `count()` буде 0.

```java
IntStream numbers = IntStream.of(1, 2, 3, 4, 5);
int count = numbers.count(); // Завжди поверне кількість елементів або 0, якщо стрім порожній

IntStream emptyStream = IntStream.empty();
int countEmpty = emptyStream.count(); // Результат буде 0, навіть якщо стрім порожній
```

Отже, використання `OptionalInt` дозволяє обробляти ситуації, коли результати можуть бути не визначені (наприклад, у порожньому стрімі), тоді як примітивний `int` використовується для методів, які завжди мають значення, навіть якщо стрім порожній.

### 12. Що таке reduction? В чому полягає різниця між mutable reduction та immutable reduction?

Reduction - це операція зведення (агрегації) в контексті Java Streams. Це процес обчислення одного результату з множини елементів, наприклад, обчислення суми, мінімального чи максимального значення, об'єднання елементів у список тощо.

1. **Mutable Reduction (змінне зведення):**
   - Mutable reduction використовується для зміни (мутації) об'єкта акумулятора під час обробки елементів стріму.
   - Наприклад, коли ви обчислюєте суму елементів у стрімі, ви постійно змінюєте значення суми, додаючи до неї кожен новий елемент.
   - Для змінного зведення використовуються методи `reduce()`, `collect()`, `sum()`, `average()`, `min()`, `max()`.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                 .reduce(0, (a, b) -> a + b); // Mutable reduction для обчислення суми
System.out.println("Sum: " + sum);
```

2. **Immutable Reduction (незмінне зведення):**
   - Immutable reduction використовується для створення нового об'єкта акумулятора під час обробки елементів стріму, зберігаючи неізменність початкового об'єкта.
   - Наприклад, коли ви об'єднуєте елементи у список або коли обчислюєте середнє значення, ви створюєте новий список або об'єкт, але не змінюєте початковий.
   - Для незмінного зведення використовуються методи `collect()`, `toList()`, `toSet()`, `toMap()`.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> squaredNumbers = numbers.stream()
                                     .map(num -> num * num)
                                     .collect(Collectors.toList()); // Immutable reduction для створення нового списку
System.out.println("Squared numbers: " + squaredNumbers);
```

Отже, різниця між mutable reduction та immutable reduction полягає у змінності об'єкта акумулятора під час обробки елементів стріму. У випадку mutable reduction змінюється початковий об'єкт акумулятора, а в immutable reduction створюється новий об'єкт, зберігаючи неізменність початкового.

---
## Висновки: у ході цієї лаборатроної роботи ми здобули нові знання у сфері роботи зi Stream API, а також змогли відпрацювати це теоретично та на практиці.
